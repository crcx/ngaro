( ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
( Retrospect by Charles Childers                              )
( This code is gifted to the public domain. Share freely.     )
( ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
( This contains a set of words I find useful while debugging  )
( code.                                                       )
(                                                             )
( Stack comments are provided for words which are intended    )
( to be used directly. Internal factors do not have the stack )
( comments provided.                                          )
( ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )

{{
  variable *addr

  : nextOp 1 *addr +! ;
  : @addr *addr @ @ ;
  : .contents @addr . ;
  : .addr *addr @ . ;

  : .ascii dup 32 >if dup 128 <if 39 emit emit 39 emit 0 then then drop ;

  : render type cr drop ;
  compiler: s:
    32 accept tib keepString literal, ['] render compile ` ;; ;

  : .name d->name type cr ;
  : resolve -1 last @ repeat dup d->xt @ @addr =if .name drop 0 ;then 0; @ again ;
  : render type 32 emit drop nextOp resolve 0; drop .contents cr ;
  compiler: x:
    32 accept tib keepString literal, ['] render compile ` ;; ;

  : decompile
    32 emit
    @addr
    dup  0 =if s: nop    then
    dup  1 =if x: lit    then
    dup  2 =if s: dup    then
    dup  3 =if s: drop   then
    dup  4 =if s: swap   then
    dup  5 =if s: push   then
    dup  6 =if s: pop    then
    dup  7 =if x: call   then
    dup  8 =if x: jump   then
    dup  9 =if s: ;      then
    dup 10 =if x: >jump  then
    dup 11 =if x: <jump  then
    dup 12 =if x: !jump  then
    dup 13 =if x: =jump  then
    dup 14 =if s: @      then
    dup 15 =if s: !      then
    dup 16 =if s: +      then
    dup 17 =if s: -      then
    dup 18 =if s: *      then
    dup 19 =if s: /mod   then
    dup 20 =if s: and    then
    dup 21 =if s: or     then
    dup 22 =if s: xor    then
    dup 23 =if s: <<     then
    dup 24 =if s: >>     then
    dup 25 =if s: 0;     then
    dup 26 =if s: 1+     then
    dup 27 =if s: 1-     then
    dup 28 =if s: in     then
    dup 29 =if s: out    then
    dup 30 =if s: wait   then
    s" unknown: " type dup . .ascii cr ;

  : more? @addr 0 =if *addr @ 1+ @ 0 =if pop drop then then ;
  : getWord ' drop which @ d->xt @ *addr ! ;

---reveal---
  : dump ( an- )  cr for @+ over 1- . . cr next drop ;
  : show ( an- ) swap *addr ! cr for .addr decompile nextOp next ;
  : see  ( "- ) getWord cr repeat .addr decompile nextOp more? again ;
}}
