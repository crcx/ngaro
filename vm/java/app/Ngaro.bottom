  }

  public void init()
  {
    sp = 0;
    rsp = 0;
    ip = 0;
    data    = new int[100];
    address = new int[100];
    ports   = new int[1024];
    memory  = new int[5000000];
    retro();

    Panel p = new Panel();

    tOutput = new TextArea(20, 80);
    tInput = new TextArea(1, 80);

    bEval = new Button("Evaluate");

    setLayout(new BorderLayout());

    p.add(tOutput);
    add("North", p);
    p = new Panel();
    p.add(tInput);
    add("Center", p);
    p = new Panel();
    p.add(bEval);
    add("South", p);
  }


  public void handleDevices()
  {
    if (ports[0] == 1)
      return;

    if (ports[0] == 0 && ports[1] == 1)
    {
      String a = tInput.getText();
      if (a == " ")
        ports[1] = 0;
      else
      {
        char b = a.charAt(0);
        tInput.setText(a.substring(1));
        ports[1] = (int)b;
        ports[0] = 1;
      }
    }
    if (ports[2] == 1)
    {
      char c = (char)data[sp];
      if (data[sp] < 0)
        tOutput.setText("");
      else
        tOutput.append(String.valueOf(c));
      sp--;
      ports[2] = 0;
      ports[0] = 1;
    }
  /* Capabilities */
  if (ports[5] == -1)
  {
    ports[5] = 5000000;
    ports[0] = 1;
  }
  if (ports[5] == -2 || ports[5] == -3 || ports[5] == -4)
  {
    ports[5] = 0;
    ports[0] = 1;
  }
  if (ports[5] == -5)
  {
    ports[5] = sp;
    ports[0] = 1;
  }
  if (ports[5] == -6)
  {
    ports[5] = rsp;
    ports[0] = 1;
  }
  }


  public void process()
  {
    int op = memory[ip];
    int x, y, z;

    switch(memory[ip])
    {
    case VM_NOP:
      break;
    case VM_LIT:
      sp++; ip++; data[sp] = memory[ip];
      break;
    case VM_DUP:
      sp++; data[sp] = data[sp-1];
      break;
    case VM_DROP:
      data[sp] = 0; sp--;
      break;
    case VM_SWAP:
      x = data[sp];
      y = data[sp-1];
      data[sp] = y;
      data[sp-1] = x;
      break;
    case VM_PUSH:
      rsp++;
      address[rsp] = data[sp];
      sp--;
      break;
    case VM_POP:
      sp++;
      data[sp] = address[rsp];
      rsp--;
      break;
    case VM_CALL:
      ip++; rsp++;
      address[rsp] = ip++;
      ip = memory[ip-1] - 1;
      break;
    case VM_JUMP:
      ip++;
      ip = memory[ip] - 1;
      break;
    case VM_RETURN:
      ip = address[rsp]; rsp--;
      break;
    case VM_GT_JUMP:
      ip++;
      if (data[sp-1] > data[sp])
        ip = memory[ip] - 1;
      sp = sp - 2;
      break;
    case VM_LT_JUMP:
      ip++;
      if (data[sp-1] < data[sp])
        ip = memory[ip] - 1;
      sp = sp - 2;
      break;
    case VM_NE_JUMP:
      ip++;
      if (data[sp-1] != data[sp])
        ip = memory[ip] - 1;
      sp = sp - 2;
      break;
    case VM_EQ_JUMP:
      ip++;
      if (data[sp-1] == data[sp])
        ip = memory[ip] - 1;
      sp = sp - 2;
      break;
    case VM_FETCH:
      x = data[sp];
      data[sp] = memory[x];
      break;
    case VM_STORE:
      memory[data[sp]] = data[sp-1];
      sp = sp - 2;
      break;
    case VM_ADD:
      data[sp-1] += data[sp]; data[sp] = 0; sp--;
      break;
    case VM_SUB:
      data[sp-1] -= data[sp]; data[sp] = 0; sp--;
      break;
    case VM_MUL:
      data[sp-1] *= data[sp]; data[sp] = 0; sp--;
      break;
    case VM_DIVMOD:
      x = data[sp];
      y = data[sp-1];
      data[sp] = y / x;
      data[sp-1] = y % x;
      break;
    case VM_AND:
      x = data[sp];
      y = data[sp-1];
      sp--;
      data[sp] = x & y;
      break;
    case VM_OR:
      x = data[sp];
      y = data[sp-1];
      sp--;
      data[sp] = x | y;
      break;
    case VM_XOR:
      x = data[sp];
      y = data[sp-1];
      sp--;
      data[sp] = x ^ y;
      break;
    case VM_SHL:
      x = data[sp];
      y = data[sp-1];
      sp--;
      data[sp] = y << x;
      break;
    case VM_SHR:
      x = data[sp];
      y = data[sp-1];
      sp--;
      data[sp] = y >>= x;
      break;
    case VM_ZERO_EXIT:
      if (data[sp] == 0)
      {
        sp--;
        ip = address[rsp]; rsp--;
      }
      break;
    case VM_INC:
      data[sp]++;
      break;
    case VM_DEC:
      data[sp]--;
      break;
    case VM_IN:
      x = data[sp];
      data[sp] = ports[x];
      ports[x] = 0;
      break;
    case VM_OUT:
      ports[0] = 0;
      ports[data[sp]] = data[sp-1];
      sp = sp - 2;
      break;
    case VM_WAIT:
      handleDevices();
      break;
    default:
      ip = 5000000;
    }
  }

  public boolean action(Event e, Object o)
  {
    String a = tInput.getText();
    tInput.setText(a + " ");

    for (; ip < 5000000; ip++)
       process();
    return false;
  }

  public static void main(String [] args)
  {
    Frame f = new Frame("Retro");
    RetroApp vm = new RetroApp();

    f.addWindowListener(new java.awt.event.WindowAdapter() {
         public void windowClosing(java.awt.event.WindowEvent e) {
         System.exit(0);
         };
       });


    vm.init();
    vm.setSize(800, 420);

    f.add("Center", vm);
    f.pack();
    f.setSize(800, 450);
    f.show();
  }
}
