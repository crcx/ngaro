Inline

1+          ( x-y )
1-          ( x-y )
swap        ( xy-yx )
drop        ( xy-x )
and         ( xy-z )
or          ( xy-z )
xor         ( xy-z )
@           ( a-n )
!           ( na- )
+           ( xy-z )
-           ( xy-z )
*           ( xy-z )
/mod        ( xy-qr )
<<          ( xy-z )
>>          ( xy-z )
nip         ( xy-y )
dup         ( n-nn )
in          ( n-n )
out         ( xy- )



Words

here        ( -a )
,           ( n- )
]           ( - )
create      ( "- )
:           ( "- )
macro:      ( "- )
compiler:   ( "- )
accept      ( n- )
cr          ( - )
emit        ( n- )
type        ( $- )
clear       ( - )
words       ( - )
key         ( -n )
over        ( xy-xyx )
2drop       ( xy- )
not         ( x-y )
rot         ( xyz-yzx )
-rot        ( xyz-xzy )
tuck        ( xy-yxy )
2dup        ( xy-xyxy )
on          ( a- )
off         ( a- )
/           ( xy-q )
mod         ( xy-r )
neg         ( x-y )
execute     ( a- )
.           ( n- )
"           ( "-$ )
compare     ( $$-f )
wait        ( - )
'           ( "-a )
@+          ( a-an )
!+
+!
-!
:is
:devector
is
devector
compile
literal,
tempString
keepString
redraw
getLength
bye
(remap-keys)
with-class
.word
.macro
.data
.inline
.compiler
d->class
d->name
d->xt
boot
depth
reset
notfound
save
>number
ok



Compiler

s"
[
;
;;
=if
>if
<if
!if
then
repeat
again
0;
push
pop
[']
for
next



Macro

(



Data

tx
ty
last
compiler
TIB
update
fb
fw
fh
#mem
heap
which
